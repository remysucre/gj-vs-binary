use indexmap::IndexMap;
use serde::{Deserialize, Serialize};

#[derive(Serialize, Deserialize, Debug, Hash, PartialEq, Eq)]
pub enum JoinType {
    Inner,
    LeftOuter,
    RightOuter,
    FullOuter,
}

#[derive(Serialize, Deserialize, Debug, Clone, PartialEq, Eq, Hash)]
pub struct Attribute {
    pub table_name: String,
    pub attr_name: String,
}

#[derive(Serialize, Deserialize, Debug, Hash, PartialEq, Eq)]
pub struct Equalizer {
    left_attr: Attribute,
    right_attr: Attribute,
}

#[derive(Serialize, Deserialize, Debug, Hash, PartialEq, Eq)]
pub struct JoinAttr {
    join_type: JoinType,
    equalizers: Vec<Equalizer>,
}

#[derive(Serialize, Deserialize, Debug, Clone, Hash, PartialEq, Eq)]
pub struct ScanAttr {
    pub table_name: String,
    pub attributes: Vec<Attribute>,
}

#[derive(Serialize, Deserialize, Debug, Hash, PartialEq, Eq)]
pub struct ProjectAttr {
    columns: Vec<Attribute>,
}

#[derive(Serialize, Deserialize, Debug, Hash, PartialEq, Eq)]
pub enum NodeAttr {
    Join(JoinAttr),
    Scan(ScanAttr),
    Project(ProjectAttr),
}

#[derive(Serialize, Deserialize, Debug, Hash, PartialEq, Eq)]
pub struct TreeOp {
    pub name: String,
    pub cardinality: u32,
    pub extra_info: String,
    pub children: Vec<Box<TreeOp>>,
    pub attr: Option<NodeAttr>,
}

pub fn preorder_traverse_mut<T>(node: &mut TreeOp, func: &mut T)
where
    T: FnMut(&mut TreeOp),
{
    func(node);
    for child_node in node.children.iter_mut() {
        preorder_traverse_mut(child_node, func);
    }
}

pub fn postorder_traverse_mut<T>(node: &mut TreeOp, func: &mut T)
where
    T: FnMut(&mut TreeOp),
{
    for child_node in node.children.iter_mut() {
        postorder_traverse_mut(child_node, func);
    }
    func(node);
}

pub fn inorder_traverse_mut<T>(node: &mut TreeOp, func: &mut T)
where
    T: FnMut(&mut TreeOp),
{
    if !node.children.is_empty() {
        inorder_traverse_mut(&mut node.children[0], func);
    }
    func(node);
    if node.children.len() > 1 {
        for child_node in &mut node.children[1..] {
            inorder_traverse_mut(child_node, func);
        }
    }
}

// fill in the attributes for scans, projections and joins
pub fn parse_tree_extra_info(root: &mut TreeOp) {
    let mut parse_func = |node: &mut TreeOp| match node.name.as_str() {
        "HASH_JOIN" => {
            let extra_info: Vec<_> = node
                .extra_info
                .split('\n')
                .filter(|s| !s.is_empty())
                .collect();

            let join_type = match extra_info[0] {
                "INNER" => JoinType::Inner,
                "MARK" => return, // mark join is essentially a filter
                _ => panic!("Fail to parse Join Type {}", extra_info[0]),
            };

            let mut equalizers = Vec::new();

            for pred in &extra_info[1..] {
                let equalizer = pred.split('=').map(|s| s.trim()).collect::<Vec<_>>();
                let left_attr = equalizer[0]
                    .split('.')
                    .map(|s| s.trim())
                    .collect::<Vec<_>>();
                let right_attr = equalizer[1]
                    .split('.')
                    .map(|s| s.trim())
                    .collect::<Vec<_>>();
                // HACK in the profile generated by unmodified duckdb
                // the table name is not included in the attribute name.
                // Here we use the attribute name as deadbeef,
                // and get the table name from the profile generated
                // by patched duckdb
                equalizers.push(Equalizer {
                    left_attr: if left_attr.len() == 1 {
                        Attribute {
                            table_name: left_attr[0].to_string(),
                            attr_name: left_attr[0].to_string(),
                        }
                    } else {
                        Attribute {
                            table_name: left_attr[0].to_string(),
                            attr_name: left_attr[1].to_string(),
                        }
                    },
                    right_attr: if right_attr.len() == 1 {
                        Attribute {
                            table_name: right_attr[0].to_string(),
                            attr_name: right_attr[0].to_string(),
                        }
                    } else {
                        Attribute {
                            table_name: right_attr[0].to_string(),
                            attr_name: right_attr[1].to_string(),
                        }
                    },
                });
            }

            node.attr = Some(NodeAttr::Join(JoinAttr {
                join_type,
                equalizers,
            }));
        }
        "SEQ_SCAN" => {
            let extra_info: Vec<_> = node.extra_info.split("[INFOSEPARATOR]").collect();
            let table_name = extra_info[0].trim();
            let info_strs: Vec<_> = extra_info[1]
                .split('\n')
                .filter(|s| !s.is_empty())
                .collect();

            node.attr = Some(NodeAttr::Scan(ScanAttr {
                table_name: table_name.to_string(),
                attributes: info_strs
                    .iter()
                    .map(|s| Attribute {
                        table_name: table_name.to_string(),
                        attr_name: s.to_string(),
                    })
                    .collect(),
            }));
        }
        "PROJECTION" => {
            let columns: Vec<_> = node
                .extra_info
                .split('\n')
                .filter(|s| !s.is_empty())
                .map(|s| {
                    let names: Vec<_> = s.split('.').map(|s| s.trim()).collect();
                    // HACK similar to the above, we use "" as deadbeef
                    // and get the table name from profile by the patched duckdb.
                    if names.len() == 1 {
                        Attribute {
                            table_name: "".to_string(),
                            attr_name: names[0].to_string(),
                        }
                    } else {
                        Attribute {
                            table_name: names[0].to_string(),
                            attr_name: names[1].to_string(),
                        }
                    }
                })
                .collect();
            node.attr = Some(NodeAttr::Project(ProjectAttr { columns }));
        }
        _ => (),
    };
    preorder_traverse_mut(root, &mut parse_func);
}

// convert a binary join tree to a gj plan, by traversing the tree in postorder
// for linear plans this will traverse the plan bottom-up
pub fn to_gj_plan(root: &mut TreeOp) -> (Vec<ScanAttr>, Vec<Vec<Attribute>>, Vec<Attribute>) {
    let mut scan: Vec<ScanAttr> = vec![];
    let mut plan: Vec<Vec<Attribute>> = vec![];
    let mut payload: Vec<Attribute> = vec![];

    let mut get_plan = |node: &mut TreeOp| {
        match &node.attr {
            Some(NodeAttr::Join(attr)) => {
                for equalizer in &attr.equalizers {
                    let lattr = &equalizer.left_attr;
                    let rattr = &equalizer.right_attr;

                    let lpos_opt = plan.iter().position(|x| x.contains(lattr));
                    let rpos_opt = plan.iter().position(|x| x.contains(rattr));

                    match (lpos_opt, rpos_opt) {
                        (Some(_lpos), Some(_rpos)) => {} // TODO add this back assert_eq!(lpos, rpos),
                        (Some(lpos), None) => plan[lpos].push(rattr.to_owned()),
                        (None, Some(rpos)) => plan[rpos].push(lattr.to_owned()),
                        (None, None) => plan.push(vec![lattr.to_owned(), rattr.to_owned()]),
                    }
                }
            }
            Some(NodeAttr::Project(cols)) => {
                payload.extend(
                    cols.columns
                        .iter()
                        .cloned()
                        .filter(|a| !a.table_name.is_empty()),
                );
            }
            Some(NodeAttr::Scan(attr)) => {
                scan.push(attr.clone());
            }
            _ => (),
        }
    };

    inorder_traverse_mut(root, &mut get_plan);

    (scan, plan, payload)
}

pub fn to_final_gj_plan(root: &mut TreeOp) -> (Vec<Vec<Attribute>>, Vec<Attribute>) {
    let mut plan: Vec<Vec<Attribute>> = vec![];
    let mut payload: Vec<Attribute> = vec![];

    let mut get_plan = |node: &TreeOp| {
        match &node.attr {
            Some(NodeAttr::Join(attr)) => {
                for equalizer in &attr.equalizers {
                    let lattr = &equalizer.left_attr;
                    let rattr = &equalizer.right_attr;

                    let lpos_opt = plan.iter().position(|x| x.contains(lattr));
                    let rpos_opt = plan.iter().position(|x| x.contains(rattr));

                    match (lpos_opt, rpos_opt) {
                        (Some(_lpos), Some(_rpos)) => {} // TODO add this back assert_eq!(lpos, rpos),
                        (Some(lpos), None) => plan[lpos].push(rattr.to_owned()),
                        (None, Some(rpos)) => plan[rpos].push(lattr.to_owned()),
                        (None, None) => plan.push(vec![lattr.to_owned(), rattr.to_owned()]),
                    }
                }
            }
            Some(NodeAttr::Project(cols)) => {
                payload.extend(
                    cols.columns
                        .iter()
                        .cloned()
                        .filter(|a| !a.table_name.is_empty()),
                );
            }
            _ => (),
        }
    };

    traverse_left(root, &mut get_plan);

    let mut add_bushy = |node: &mut TreeOp| {
        if let Some(NodeAttr::Join(attr)) = &node.attr {
            for equalizer in &attr.equalizers {
                let lattr = &equalizer.left_attr;
                let rattr = &equalizer.right_attr;
    
                let lpos_opt = plan.iter().position(|x| x.contains(lattr));
                let rpos_opt = plan.iter().position(|x| x.contains(rattr));
    
                match (lpos_opt, rpos_opt) {
                    (Some(_lpos), Some(_rpos)) => {} // TODO add this back assert_eq!(lpos, rpos),
                    (Some(lpos), None) => plan[lpos].push(rattr.to_owned()),
                    (None, Some(rpos)) => plan[rpos].push(lattr.to_owned()),
                    _ => (),
                    // (None, None) => plan.push(vec![lattr.to_owned(), rattr.to_owned()]),
                }
            }
        }
    };

    inorder_traverse_mut(root, &mut add_bushy);

    (plan, payload)
}

pub fn to_semijoin_plan(root: &TreeOp) -> Vec<Vec<Attribute>> {
    let mut plan:Vec<Vec<Attribute>> = vec![];
    let mut build_plan = |node: &TreeOp| {
        if let Some(NodeAttr::Join(attr)) = &node.attr {
            for equalizer in &attr.equalizers {
                let lattr = &equalizer.left_attr;
                let rattr = &equalizer.right_attr;

                let lpos_opt = plan.iter().position(|x| x.contains(lattr));
                let rpos_opt = plan.iter().position(|x| x.contains(rattr));

                match (lpos_opt, rpos_opt) {
                    (Some(_lpos), Some(_rpos)) => {} // TODO add this back assert_eq!(lpos, rpos),
                    (Some(lpos), None) => plan[lpos].push(rattr.to_owned()),
                    (None, Some(rpos)) => plan[rpos].push(lattr.to_owned()),
                    (None, None) => plan.push(vec![lattr.to_owned(), rattr.to_owned()]),
                }
            }
        }
    };
    traverse_left(root, &mut build_plan);
    plan
}

fn traverse_left<'a, T>(node: &'a TreeOp, func: &mut T)
where
    T: FnMut(&'a TreeOp),
{
    if !node.children.is_empty() {
        traverse_left(&node.children[0], func);
    }
    func(node);
}

pub fn travers_lrm<'a, T>(node: &'a TreeOp, func: &mut T, is_right_child: bool)
where
    T: FnMut(&'a TreeOp, bool),
{
    if !node.children.is_empty() {
        travers_lrm(&node.children[0], func, false);
    }
    if node.children.len() > 1 {
        for child_node in &node.children[1..] {
            travers_lrm(child_node, func, true);
        }
    }
    func(node, is_right_child);
}

pub fn traverse_mlr<'a, T>(node: &'a TreeOp, func: &mut T, is_right_child: bool)
where
    T: FnMut(&'a TreeOp, bool),
{
    func(node, is_right_child);

    if !node.children.is_empty() {
        traverse_mlr(&node.children[0], func, false);
    }

    if node.children.len() > 1 {
        for child_node in &node.children[1..] {
            traverse_mlr(child_node, func, true);
        }
    }
}

// pub fn to_reduce<'a>(root: &'a TreeOp) -> Vec<&'a TreeOp> {
//     let mut to_reduce = vec![];

//     let mut build_plan = |node: &'a TreeOp, is_right_child: bool| {
//         if let Some(NodeAttr::Join(_)) = &node.attr {
//             if is_right_child {
//                 to_reduce.push(node);
//             }
//         }
//     };

//     travers_lrm(root, &mut build_plan, false);
//     to_reduce
// }

pub fn required_vars<'a>(root: &'a TreeOp) -> (Vec<&'a Attribute>, IndexMap<&'a TreeOp, usize>) {
    let mut current_vars = Vec::new();
    let mut required_vars = IndexMap::new();

    let mut build_plan = |node: &'a TreeOp, is_right_child| {
        if let Some(NodeAttr::Join(attr)) = &node.attr {
            if is_right_child {
                required_vars.insert(node, current_vars.len());
            }
            current_vars.push(&attr.equalizers[0].left_attr);
            current_vars.push(&attr.equalizers[0].right_attr);
        }
    };
    traverse_mlr(root, &mut build_plan, false);
    (current_vars, required_vars)
}