Generic join incurs a linear-ish ($O(n \log (n))$) overhead to sort the input relations. This is fine in most cases, since both merge-sort join and hash join need to scan the entire input relations. However, index join may touch only a tiny fraction of the indexed relation, so we cannot afford to sort the entire relation for generic join. 

The solution is to also create indices for generic join. An index is simply a partially sorted trie. For example, an index for `R(x,y,z,w)` on `x` is a 2-level trie, where the first level stores `x` in sorted order, and each `x` points to an unsorted set of tuples `(y,z,w)`. During generic join execution, we may directly intersect with the pre-sorted `x` level. For each `x` value in the intersection, we can now sort `(y,z,w)` so that we can intersect with them further down the loop. This lazy sorting saves us time from sorting tuples in regions not returned from the index join on `x`. 

This however slightly complicates the implementation, since we now need to interrupt generic join with sorting. This means we need to modify TACO to generate calls to `sort` in the middle of generic join. 